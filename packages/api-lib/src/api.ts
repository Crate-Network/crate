/* tslint:disable */
/* eslint-disable */
/**
 * Crate Network API
 * ## About this spec  The Crate API exposes several endpoints which allows the Crate macOS, iOS,  iPadOS and web clients to interact with Crate\'s IPFS cluster without the  clients needing to run IPFS clients of their own. Crate Network implements  the IPFS Pinning API specification at the `/pins` endpoint, as described by  the spec found [on GitHub](https://github.com/ipfs/pinning-services-api-spec/blob/3196b0b466752a3626b716969703cbd48cb9bcf7/ipfs-pinning-service.yaml).  The pinning API accepts a Bearer authorization token retrieved from your Crate account. This identifies your user and adds the pinned content to  your files on Crate. This version of the API is modified to include  metadata, all of which is optional so that Crate continues to conform to  the IPFS spec.  The Filecoin replication service is handled via the pinning API. Instead of  using untrusted centralized cloud storage as the backend, Crate safely  replicates content onto other decentralized networks. When a request comes  to the pinning service to retrieve the content, Crate will prioritize  cached content, otherwise falling back to the Filecoin network to retrieve your files. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Response for a failed request
 * @export
 * @interface Failure
 */
export interface Failure {
    /**
     * 
     * @type {FailureError}
     * @memberof Failure
     */
    'error': FailureError;
}
/**
 * 
 * @export
 * @interface FailureError
 */
export interface FailureError {
    /**
     * Mandatory string identifying the type of error
     * @type {string}
     * @memberof FailureError
     */
    'reason': string;
    /**
     * Optional, longer description of the error; may include UUID of transaction for support, links to documentation etc
     * @type {string}
     * @memberof FailureError
     */
    'details'?: string;
}
/**
 * A file object as represented on @crate/web
 * @export
 * @interface FileModel
 */
export interface FileModel {
    /**
     * Content Identifier (CID)
     * @type {string}
     * @memberof FileModel
     */
    'cid': string;
    /**
     * File name without extension
     * @type {string}
     * @memberof FileModel
     */
    'name': string;
    /**
     * Whether this is a file or directory
     * @type {string}
     * @memberof FileModel
     */
    'type': FileModelTypeEnum;
    /**
     * Encryption key for the file in string format, parsed from binary representation in UTF-8. This key has been encrypted by the user\'s data key. If this exists, it means the file is for private consumption. 
     * @type {string}
     * @memberof FileModel
     */
    'signedEncryptionKey'?: string;
    /**
     * The size of the file.
     * @type {number}
     * @memberof FileModel
     */
    'size': number;
    /**
     * The date that this file was last modified in ISO-8601.
     * @type {string}
     * @memberof FileModel
     */
    'date': string;
    /**
     * The CIDs linked to from this directory. 
     * @type {Array<FileModelLinksInner>}
     * @memberof FileModel
     */
    'links'?: Array<FileModelLinksInner>;
    /**
     * The size of the directory and all contained files.
     * @type {number}
     * @memberof FileModel
     */
    'cumulativeSize'?: number;
    /**
     * Permissions for file.
     * @type {number}
     * @memberof FileModel
     */
    'mode': number;
}

export const FileModelTypeEnum = {
    Directory: 'directory',
    File: 'file'
} as const;

export type FileModelTypeEnum = typeof FileModelTypeEnum[keyof typeof FileModelTypeEnum];

/**
 * Structure for linked items in a directory. Name can vary from  directory to directory. 
 * @export
 * @interface FileModelLinksInner
 */
export interface FileModelLinksInner {
    /**
     * Content Identifier (CID)
     * @type {string}
     * @memberof FileModelLinksInner
     */
    'cid': string;
    /**
     * Name of linked file.
     * @type {string}
     * @memberof FileModelLinksInner
     */
    'name': string;
    /**
     * Size of linked file.
     * @type {number}
     * @memberof FileModelLinksInner
     */
    'size': number;
}
/**
 * Pin object
 * @export
 * @interface Pin
 */
export interface Pin {
    /**
     * Content Identifier (CID)
     * @type {string}
     * @memberof Pin
     */
    'cid': string;
    /**
     * Optional name for pinned data; can be used for lookups later
     * @type {string}
     * @memberof Pin
     */
    'name'?: string;
    /**
     * Optional list of multiaddrs known to provide the data; see Provider Hints in the docs
     * @type {Set<string>}
     * @memberof Pin
     */
    'origins'?: Set<string>;
    /**
     * Optional metadata for pin object
     * @type {{ [key: string]: string; }}
     * @memberof Pin
     */
    'meta'?: { [key: string]: string; };
}
/**
 * Response used for listing pin objects matching request
 * @export
 * @interface PinResults
 */
export interface PinResults {
    /**
     * The total number of pin objects that exist for passed query filters
     * @type {number}
     * @memberof PinResults
     */
    'count': number;
    /**
     * An array of PinStatus results
     * @type {Set<PinStatus>}
     * @memberof PinResults
     */
    'results': Set<PinStatus>;
}
/**
 * Pin object with status
 * @export
 * @interface PinStatus
 */
export interface PinStatus {
    /**
     * Globally unique identifier of the pin request; can be used to check the status of ongoing pinning, or pin removal
     * @type {string}
     * @memberof PinStatus
     */
    'requestid': string;
    /**
     * 
     * @type {Status}
     * @memberof PinStatus
     */
    'status': Status;
    /**
     * Immutable timestamp indicating when a pin request entered a pinning service; can be used for filtering results and pagination
     * @type {string}
     * @memberof PinStatus
     */
    'created': string;
    /**
     * 
     * @type {Pin}
     * @memberof PinStatus
     */
    'pin': Pin;
    /**
     * List of multiaddrs designated by pinning service that will receive the  pin data; see Provider Hints in the docs 
     * @type {Set<string>}
     * @memberof PinStatus
     */
    'delegates': Set<string>;
    /**
     * Optional info for PinStatus response
     * @type {{ [key: string]: string; }}
     * @memberof PinStatus
     */
    'info'?: { [key: string]: string; };
}
/**
 * Status a pin object can have at a pinning service
 * @export
 * @enum {string}
 */

export const Status = {
    Queued: 'queued',
    Pinning: 'pinning',
    Pinned: 'pinned',
    Failed: 'failed'
} as const;

export type Status = typeof Status[keyof typeof Status];


/**
 * Alternative text matching strategy
 * @export
 * @enum {string}
 */

export const TextMatchingStrategy = {
    Exact: 'exact',
    Iexact: 'iexact',
    Partial: 'partial',
    Ipartial: 'ipartial'
} as const;

export type TextMatchingStrategy = typeof TextMatchingStrategy[keyof typeof TextMatchingStrategy];



/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get FileModel object a file/directory specified by either a CID or the path from the root of the user\'s filesystem. If neither are  specified, we return the FileModel for the root directory. 
         * @summary Fetches FileModel for a CID or path
         * @param {string} [path] 
         * @param {string} [cid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileGet: async (path?: string, cid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (cid !== undefined) {
                localVarQueryParameter['cid'] = cid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload one or many files/directories to a path specified in the query parameters. If ignored, this will save the files to the root directory. 
         * @param {string} [path] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filePost: async (path?: string, files?: Array<any>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get FileModel object a file/directory specified by either a CID or the path from the root of the user\'s filesystem. If neither are  specified, we return the FileModel for the root directory. 
         * @summary Fetches FileModel for a CID or path
         * @param {string} [path] 
         * @param {string} [cid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileGet(path?: string, cid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileGet(path, cid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload one or many files/directories to a path specified in the query parameters. If ignored, this will save the files to the root directory. 
         * @param {string} [path] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filePost(path?: string, files?: Array<any>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filePost(path, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * Get FileModel object a file/directory specified by either a CID or the path from the root of the user\'s filesystem. If neither are  specified, we return the FileModel for the root directory. 
         * @summary Fetches FileModel for a CID or path
         * @param {string} [path] 
         * @param {string} [cid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileGet(path?: string, cid?: string, options?: any): AxiosPromise<FileModel> {
            return localVarFp.fileGet(path, cid, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload one or many files/directories to a path specified in the query parameters. If ignored, this will save the files to the root directory. 
         * @param {string} [path] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filePost(path?: string, files?: Array<any>, options?: any): AxiosPromise<Array<FileModel>> {
            return localVarFp.filePost(path, files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * Get FileModel object a file/directory specified by either a CID or the path from the root of the user\'s filesystem. If neither are  specified, we return the FileModel for the root directory. 
     * @summary Fetches FileModel for a CID or path
     * @param {string} [path] 
     * @param {string} [cid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public fileGet(path?: string, cid?: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).fileGet(path, cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload one or many files/directories to a path specified in the query parameters. If ignored, this will save the files to the root directory. 
     * @param {string} [path] 
     * @param {Array<any>} [files] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filePost(path?: string, files?: Array<any>, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filePost(path, files, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PinsApi - axios parameter creator
 * @export
 */
export const PinsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all the pin objects, matching optional filters; when no filter is provided, only successful pins are returned.
         * @summary List pin objects
         * @param {Set<string>} [cid] Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts
         * @param {string} [name] Return pin objects with specified name (by default a case-sensitive, exact match)
         * @param {TextMatchingStrategy} [match] Customize the text matching strategy applied when the name filter is present; exact (the default) is a case-sensitive exact match, partial matches anywhere in the name, iexact and ipartial are case-insensitive versions of the exact and partial strategies
         * @param {Set<Status>} [status] Return pin objects for pins with the specified status
         * @param {string} [before] Return results created (queued) before provided timestamp
         * @param {string} [after] Return results created (queued) after provided timestamp
         * @param {number} [limit] Max records to return
         * @param {any} [meta] Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsGet: async (cid?: Set<string>, name?: string, match?: TextMatchingStrategy, status?: Set<Status>, before?: string, after?: string, limit?: number, meta?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cid) {
                localVarQueryParameter['cid'] = Array.from(cid).join(COLLECTION_FORMATS.csv);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            if (status) {
                localVarQueryParameter['status'] = Array.from(status).join(COLLECTION_FORMATS.csv);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = (after as any instanceof Date) ?
                    (after as any).toISOString() :
                    after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new pin object for the current access token
         * @summary Add pin object
         * @param {Pin} pin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsPost: async (pin: Pin, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pin' is not null or undefined
            assertParamExists('pinsPost', 'pin', pin)
            const localVarPath = `/pins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a pin object
         * @summary Remove pin object
         * @param {string} requestid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsRequestidDelete: async (requestid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestid' is not null or undefined
            assertParamExists('pinsRequestidDelete', 'requestid', requestid)
            const localVarPath = `/pins/{requestid}`
                .replace(`{${"requestid"}}`, encodeURIComponent(String(requestid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a pin object and its status
         * @summary Get pin object
         * @param {string} requestid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsRequestidGet: async (requestid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestid' is not null or undefined
            assertParamExists('pinsRequestidGet', 'requestid', requestid)
            const localVarPath = `/pins/{requestid}`
                .replace(`{${"requestid"}}`, encodeURIComponent(String(requestid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace an existing pin object (shortcut for executing remove and add operations in one step to avoid unnecessary garbage collection of blocks present in both recursive pins)
         * @summary Replace pin object
         * @param {string} requestid 
         * @param {Pin} pin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsRequestidPost: async (requestid: string, pin: Pin, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestid' is not null or undefined
            assertParamExists('pinsRequestidPost', 'requestid', requestid)
            // verify required parameter 'pin' is not null or undefined
            assertParamExists('pinsRequestidPost', 'pin', pin)
            const localVarPath = `/pins/{requestid}`
                .replace(`{${"requestid"}}`, encodeURIComponent(String(requestid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PinsApi - functional programming interface
 * @export
 */
export const PinsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PinsApiAxiosParamCreator(configuration)
    return {
        /**
         * List all the pin objects, matching optional filters; when no filter is provided, only successful pins are returned.
         * @summary List pin objects
         * @param {Set<string>} [cid] Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts
         * @param {string} [name] Return pin objects with specified name (by default a case-sensitive, exact match)
         * @param {TextMatchingStrategy} [match] Customize the text matching strategy applied when the name filter is present; exact (the default) is a case-sensitive exact match, partial matches anywhere in the name, iexact and ipartial are case-insensitive versions of the exact and partial strategies
         * @param {Set<Status>} [status] Return pin objects for pins with the specified status
         * @param {string} [before] Return results created (queued) before provided timestamp
         * @param {string} [after] Return results created (queued) after provided timestamp
         * @param {number} [limit] Max records to return
         * @param {any} [meta] Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinsGet(cid?: Set<string>, name?: string, match?: TextMatchingStrategy, status?: Set<Status>, before?: string, after?: string, limit?: number, meta?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PinResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinsGet(cid, name, match, status, before, after, limit, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new pin object for the current access token
         * @summary Add pin object
         * @param {Pin} pin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinsPost(pin: Pin, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PinStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinsPost(pin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a pin object
         * @summary Remove pin object
         * @param {string} requestid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinsRequestidDelete(requestid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinsRequestidDelete(requestid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a pin object and its status
         * @summary Get pin object
         * @param {string} requestid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinsRequestidGet(requestid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PinStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinsRequestidGet(requestid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace an existing pin object (shortcut for executing remove and add operations in one step to avoid unnecessary garbage collection of blocks present in both recursive pins)
         * @summary Replace pin object
         * @param {string} requestid 
         * @param {Pin} pin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinsRequestidPost(requestid: string, pin: Pin, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PinStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinsRequestidPost(requestid, pin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PinsApi - factory interface
 * @export
 */
export const PinsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PinsApiFp(configuration)
    return {
        /**
         * List all the pin objects, matching optional filters; when no filter is provided, only successful pins are returned.
         * @summary List pin objects
         * @param {Set<string>} [cid] Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts
         * @param {string} [name] Return pin objects with specified name (by default a case-sensitive, exact match)
         * @param {TextMatchingStrategy} [match] Customize the text matching strategy applied when the name filter is present; exact (the default) is a case-sensitive exact match, partial matches anywhere in the name, iexact and ipartial are case-insensitive versions of the exact and partial strategies
         * @param {Set<Status>} [status] Return pin objects for pins with the specified status
         * @param {string} [before] Return results created (queued) before provided timestamp
         * @param {string} [after] Return results created (queued) after provided timestamp
         * @param {number} [limit] Max records to return
         * @param {any} [meta] Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsGet(cid?: Set<string>, name?: string, match?: TextMatchingStrategy, status?: Set<Status>, before?: string, after?: string, limit?: number, meta?: any, options?: any): AxiosPromise<PinResults> {
            return localVarFp.pinsGet(cid, name, match, status, before, after, limit, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new pin object for the current access token
         * @summary Add pin object
         * @param {Pin} pin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsPost(pin: Pin, options?: any): AxiosPromise<PinStatus> {
            return localVarFp.pinsPost(pin, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a pin object
         * @summary Remove pin object
         * @param {string} requestid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsRequestidDelete(requestid: string, options?: any): AxiosPromise<void> {
            return localVarFp.pinsRequestidDelete(requestid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a pin object and its status
         * @summary Get pin object
         * @param {string} requestid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsRequestidGet(requestid: string, options?: any): AxiosPromise<PinStatus> {
            return localVarFp.pinsRequestidGet(requestid, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace an existing pin object (shortcut for executing remove and add operations in one step to avoid unnecessary garbage collection of blocks present in both recursive pins)
         * @summary Replace pin object
         * @param {string} requestid 
         * @param {Pin} pin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsRequestidPost(requestid: string, pin: Pin, options?: any): AxiosPromise<PinStatus> {
            return localVarFp.pinsRequestidPost(requestid, pin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PinsApi - object-oriented interface
 * @export
 * @class PinsApi
 * @extends {BaseAPI}
 */
export class PinsApi extends BaseAPI {
    /**
     * List all the pin objects, matching optional filters; when no filter is provided, only successful pins are returned.
     * @summary List pin objects
     * @param {Set<string>} [cid] Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts
     * @param {string} [name] Return pin objects with specified name (by default a case-sensitive, exact match)
     * @param {TextMatchingStrategy} [match] Customize the text matching strategy applied when the name filter is present; exact (the default) is a case-sensitive exact match, partial matches anywhere in the name, iexact and ipartial are case-insensitive versions of the exact and partial strategies
     * @param {Set<Status>} [status] Return pin objects for pins with the specified status
     * @param {string} [before] Return results created (queued) before provided timestamp
     * @param {string} [after] Return results created (queued) after provided timestamp
     * @param {number} [limit] Max records to return
     * @param {any} [meta] Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinsApi
     */
    public pinsGet(cid?: Set<string>, name?: string, match?: TextMatchingStrategy, status?: Set<Status>, before?: string, after?: string, limit?: number, meta?: any, options?: AxiosRequestConfig) {
        return PinsApiFp(this.configuration).pinsGet(cid, name, match, status, before, after, limit, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new pin object for the current access token
     * @summary Add pin object
     * @param {Pin} pin 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinsApi
     */
    public pinsPost(pin: Pin, options?: AxiosRequestConfig) {
        return PinsApiFp(this.configuration).pinsPost(pin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a pin object
     * @summary Remove pin object
     * @param {string} requestid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinsApi
     */
    public pinsRequestidDelete(requestid: string, options?: AxiosRequestConfig) {
        return PinsApiFp(this.configuration).pinsRequestidDelete(requestid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a pin object and its status
     * @summary Get pin object
     * @param {string} requestid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinsApi
     */
    public pinsRequestidGet(requestid: string, options?: AxiosRequestConfig) {
        return PinsApiFp(this.configuration).pinsRequestidGet(requestid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace an existing pin object (shortcut for executing remove and add operations in one step to avoid unnecessary garbage collection of blocks present in both recursive pins)
     * @summary Replace pin object
     * @param {string} requestid 
     * @param {Pin} pin 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinsApi
     */
    public pinsRequestidPost(requestid: string, pin: Pin, options?: AxiosRequestConfig) {
        return PinsApiFp(this.configuration).pinsRequestidPost(requestid, pin, options).then((request) => request(this.axios, this.basePath));
    }
}


